<!doctype html>
<html lang="en-us">

<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Emscripten-Generated Code</title>
</head>

<body>
	<p>Check console</p>
	<script async type="text/javascript" src="sskr.js"></script>
	<script>
		// https://kapadia.github.io/emscripten/2013/09/13/emscripten-pointers-and-pointers.html
		const allocateMemory = (length) => {
			const output = new Uint16Array(length)
			var nOutputBytes = output.length * output.BYTES_PER_ELEMENT;
			var outputPtr = Module._malloc(nOutputBytes);
			var heap = new Uint8Array(Module.HEAPU8.buffer, outputPtr, nOutputBytes);
			heap.set(new Uint8Array(output.buffer));
			return {
				output,
				heap
			}
		}

		const hexStringToUint8Array = (data) => {
			var bytes = new Uint8Array(Math.ceil(data.length / 2));
			for (var i = 0; i < bytes.length; i++) bytes[i] = parseInt(data.substr(i * 2, 2), 16);
			return bytes
		}

		const toHexString = (bytes) =>
			bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');

		// We need a timeout because the JS/WASM file needs some time to load. There is probably a ready event for this
		setTimeout(() => {
			var sskrShardCount = Module.cwrap(
				'sskr_count_shards', // name of C function
				'number', // return type
				['number', 'array', 'number'], // argument types
			);

			// https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#calling-compiled-c-functions-from-javascript-using-ccall-cwrap

			/*
			int sskr_generate(
			    size_t group_threshold,
			    const sskr_group_descriptor *groups,
			    size_t groups_len,
			    const uint8_t *master_secret, 
			    size_t master_secret_len,
			    size_t *shard_len,
			    uint8_t *output,
			    size_t buffer_size,
			    void* ctx,
			    void (*random_generator)(uint8_t *, size_t, void*)
			) {
			*/

			var sskrGenerate = Module.cwrap(
				'sskr_generate', // name of C function
				'number', // return type
				['number', 'array', 'number', /*'string'*/ 'array', 'number', 'number', 'number', 'number', 'number', 'number'], // argument types
			);

			var sskrCombine = Module.cwrap(
				'sskr_combine', // name of C function
				'number', // return type
				['number', 'number', 'number', 'number', 'number'], // argument types
			);

			const groups = new Uint16Array(16)
			const view = new DataView(groups.buffer)
			view.setUint16(0, 2, true)
			view.setUint16(8, 3, true)
			view.setUint16(16, 3, true)
			view.setUint16(24, 5, true)
			console.log('groups', groups)
			const buffer = Module._malloc(groups.length);
			Module.HEAPU16.set(groups, buffer);

			const groupThreshold = 2


			const expectedShardCount = sskrShardCount(groupThreshold, groups, groups.length / 8)
			console.log('expectedShardCount', expectedShardCount)


			/// test
			console.log("moj")
			//const groups_ = new Uint32Array(4);
			const groups_ = new Uint8Array([2, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0]); // DELA
			//const groups_ = Module._malloc(100);

			//setValue(groups_ + 0, 2, 'i32')
			//setValue(groups_ + 1, 3, 'i32')
			//setValue(groups_ + 2, 3, 'i32')
			//setValue(groups_ + 3, 5, 'i32')
			var expectedShardCount_ = ccall("sskr_count_shards", "number", ["number", "array", "number"], [groupThreshold, groups_, /*groups_.length / 2*/ 2]);
			console.log('test: ', expectedShardCount_);
			// TEST END


			const masterSecretString = '7daa851251002874e1a1995f0897e6b1'
			const masterSecret = hexStringToUint8Array(masterSecretString)
			const masterSecretLen = masterSecretString.length / 2
			console.log('masterSecretLen', masterSecretLen)

			const expectedShardLen = masterSecretLen + 5

			const bufferLen = 8 * expectedShardLen

			// https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#calling-javascript-functions-as-function-pointers-from-c
			// https://github.com/emscripten-core/emscripten/blob/master/tests/interop/test_add_function_post.js
			var newFuncPtr = addFunction(function(bufferPointer, count, contextPointer) {
				// Set identifier to 0, setting it to other values doesn't work as expected
				setValue(bufferPointer, 0, /*'*'*/ 'i32')
				out('Debug: Value at pointer', getValue(bufferPointer, 'i32'))
				out('Debug: ' + bufferPointer + ' ' + count + ' ' + contextPointer);
			}, 'viii');

			const {
				output: shardLen,
				heap: shardLenHeap
			} = allocateMemory(1)
			const {
				output: output,
				heap: outputHeap
			} = allocateMemory(bufferLen)


			// test


			/*
			int sskr_generate(
			    size_t group_threshold,
			    const sskr_group_descriptor *groups,
			    size_t groups_len,
			    const uint8_t *master_secret, 
			    size_t master_secret_len,
			    size_t *shard_len,
			    uint8_t *output,
			    size_t buffer_size,
			    void* ctx,
			    void (*random_generator)(uint8_t *, size_t, void*)
			) {
			*/

			var shard_len = Module._malloc(4);
			var buffer_len = 420 // TODO this valu was checke in CLI
			var output_ = Module._malloc(buffer_len); // TODO!
			//var output_ = new Uint8Array(buffer_len);


			var master_secret_str_ = "7daa851251002874e1a1995f0897e6b1";

			const fromHexString = hexString =>
				new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

			const rs = fromHexString(master_secret_str_);

			console.log("rall s", rs);


			const shardCount = sskrGenerate(
				groupThreshold,
				groups_,
				/*groups.length / 8*/
				2,
				//masterSecretString
				rs,
				/*masterSecretString.length / 2*/
				16,
				shardLenHeap.byteOffset,
				outputHeap.byteOffset,
				output.length,
				/*undefined*/
				null,
				newFuncPtr
			)

			console.log('shardCount', shardCount)

			if (shardCount < 0) {
				console.log('shardCount Error')
				return
			}

			var shardLenResult = new Uint8Array(shardLenHeap.buffer, shardLenHeap.byteOffset, shardLen.length)[0];
			var outputResult = new Uint8Array(outputHeap.buffer, outputHeap.byteOffset, output.length);

			console.log('shardLenResult', shardLenResult)
			console.log('outputResult', outputResult)

			console.log('--- ASSERT shardCount: ', shardCount === expectedShardCount, shardCount, expectedShardCount)
			console.log('--- ASSERT shardLen: ', shardLenResult === expectedShardLen, shardLenResult, expectedShardLen)

			console.log('--- SHARDS START ---')
			const shards = []
			for (let x = 0; x < shardCount; x++) {
				const pos = x * expectedShardLen
				const slice = outputResult.slice(pos, pos + expectedShardLen)
				// console.log(slice)

				// const view = new DataView(slice.buffer)

				// if (x === 0) {
				//   for(let y = 0; y < expectedShardLen; y++) {
				//     console.log(view.getUint8(y).toString(16))
				//   }
				// }


				const shard = toHexString(slice)
				shards.push(shard)
				// This doesn't seem to be a valid shard
				console.log(shard)
			}
			console.log('--- SHARDS END ---')

			// this are results for identifier=0x0000. Checkd in console
			const recovery = [
				'00001101009be4050ec500e6e94ba77a399086359c',
				'00001101016360e1b2bd00a5485d4ea9c221d6ef0c',
				'00001112017f1c42f729006bd5f7484aa4b9c73c21',
				'0000111202e5a909d4af002692857bef8a59ca1ac9',
				'00001112039ab54b2386004d477233a52ee00d26e8',
			]

			var width = 21;
			var height = 5;

			// https://kapadia.github.io/emscripten/2013/09/13/emscripten-pointers-and-pointers.html
			var data = new Uint8Array(height * width);


			for (var i = 0; i < width * height; i++) {
				data[i] = i;
			}


			var nDataBytes = data.length * data.BYTES_PER_ELEMENT;
			var dataPtr = Module._malloc(nDataBytes);



			var dataHeap1 = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
			dataHeap1.set(new Uint8Array(data.buffer));

			var pointers = new Uint32Array(height);
			for (var i = 0; i < pointers.length; i++) {
				pointers[i] = dataPtr + i * data.BYTES_PER_ELEMENT * width;
			}

			// Allocate bytes needed for the array of pointers
			var nPointerBytes = pointers.length * pointers.BYTES_PER_ELEMENT
			var pointerPtr = Module._malloc(nPointerBytes);

			// Copy array of pointers to Emscripten heap
			var pointerHeap = new Uint8Array(Module.HEAPU8.buffer, pointerPtr, nPointerBytes);
			pointerHeap.set(new Uint8Array(pointers.buffer));


			//var a = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 4, 5, 6, 7, 1, 1, 1, 1, 1, 1, ]);
			//pointerHeap.set(new Uint8Array([a, a, a, a, a, a]));

			// Should this be 100?
			const {
				output: recover,
				heap: recoverHeap
			} = allocateMemory(100)


			/// test2
			//console.log("moj2")
			//const groups_ = new Uint32Array(4);
			//const groups_ = new Uint8Array([2, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0]); // DELA
			//const groups_ = Module._malloc(100);

			/*
			int sskr_combine(
			    const uint8_t **input_shards, // array of pointers to 10-bit words
			    size_t shard_len,   // number of bytes in each serialized shard
			    size_t shards_count,  // total number of shards
			    uint8_t *buffer,            // working space, and place to return secret
			    size_t buffer_len      // total amount of working space
			*/



			//var shards_ = new Uint8Array([1, 1, 1, 1, 1]);

			const shards_ = Module._malloc(1000);

			//setValue(shards_ + 0, 2, '*') setValue(shards_ + 1, 3, '*') setValue(shards_ + 2, 3, '*') setValue(shards_ + 3, 5, '*')


			//var expectedShardCount_ = ccall("sskr_combine", "number", ["number", "number", "number", "number", "number"], [shards_, width, height, recoverHeap.byteOffset, recover.length]);
			//console.log('test: ', expectedShardCount_);
			// TEST2 END


			//var shards_ = new Uint8Array(10000);

			// This doesn't work yet
			const combineResult = sskrCombine(pointerHeap.byteOffset, width, height, recoverHeap.byteOffset, recover.length)
			console.log('combineResult', combineResult)



		}, 1000)
	</script>
</body>

</html>